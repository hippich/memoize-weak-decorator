{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap e3cc47e864d0440a1d79","webpack:///./src/memoize.ts"],"names":[],"mappings":"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","file":"memoize.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"memoize\"] = factory();\n\telse\n\t\troot[\"memoize\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap e3cc47e864d0440a1d79","/**\n * @author adufilie http://github.com/adufilie\n */\n\nconst UNDEFINED = {} as any;\n\nexport type AnyFunction = (...args:any[])=>any;\n\nfunction isPrimitive(value:any):boolean\n{\n\treturn value === null || typeof value !== 'object';\n}\n\n/**\n * Provides Map-like interface that uses Map for primitive keys and WeakMap for non-primitive keys.\n */\nexport class MeekMap<K,V>\n{\n\tprivate map = new Map<any, V>();\n\tprivate weakMap = new WeakMap<any, V>();\n\n\thas(key:K):boolean\n\t{\n\t\treturn isPrimitive(key) ? this.map.has(key) : this.weakMap.has(key);\n\t}\n\tget(key:K):V|undefined\n\t{\n\t\treturn isPrimitive(key) ? this.map.get(key) : this.weakMap.get(key);\n\t}\n\tset(key:K, value:V):this\n\t{\n\t\tif (isPrimitive(key))\n\t\t\tthis.map.set(key, value);\n\t\telse\n\t\t\tthis.weakMap.set(key, value);\n\t\treturn this;\n\t}\n}\n\n/**\n * Provides a multi-dimensional Map-like interface\n */\nexport class HyperMap<T>\n{\n\thas(args:any[]):boolean\n\t{\n\t\tlet cache:MeekMap<any, any>|undefined = this.getCache(args.length);\n\t\tif (args.length > 1)\n\t\t\tcache = this.traverse(cache, args.slice(0, args.length - 1)) as any;\n\t\treturn cache !== undefined && cache.has(args[args.length - 1]);\n\t}\n\n\tget(args:any[]):T | undefined\n\t{\n\t\treturn this.traverse(this.getCache(args.length), args);\n\t}\n\n\tset(args:any[], value:T):void\n\t{\n\t\tthis.traverse(this.getCache(args.length), args, value);\n\t}\n\n\t// gets the Cache designated for a specific key length\n\tprivate getCache(numArgs:number)\n\t{\n\t\tlet cache = this.map_numArgs_cache.get(numArgs);\n\t\tif (!cache)\n\t\t\tthis.map_numArgs_cache.set(numArgs, cache = new MeekMap());\n\t\treturn cache;\n\t}\n\n\t// used to avoiding the varying-key-length limitation of the traverse() function below\n\tprivate map_numArgs_cache = new Map<number, MeekMap<any, any>>();\n\n\t// dual-purpose setter/getter\n\t// note: does not work if subsequent calls vary the length of the keys array for the same cache param\n\tprivate traverse(cache:MeekMap<any, any>, keys:any[], value?:T):T|undefined\n\t{\n\t\tif (keys.length == 0)\n\t\t\treturn undefined;\n\t\tif (keys.length == 1)\n\t\t{\n\t\t\tif (value === undefined)\n\t\t\t\treturn cache.get(keys[0]);\n\t\t\treturn void cache.set(keys[0], value);\n\t\t}\n\n\t\tlet nextCache = cache.get(keys[0]);\n\t\tif (nextCache === undefined)\n\t\t\tcache.set(keys[0], nextCache = new MeekMap());\n\t\treturn this.traverse(nextCache, keys.slice(1), value);\n\t}\n}\n\nclass Memoizer<Result, Func extends (...args:any[])=>Result>\n{\n\tprivate func:Func;\n\tprivate cache = new HyperMap<Result>();\n\n\tconstructor(func:Func, getAdditionalArgs?:()=>any[], fixedArgsLength?:number)\n\t{\n\t\tthis.func = func;\n\t\tlet cache = this.cache;\n\t\tthis.get = function(...args:any[]) {\n\t\t\tif (fixedArgsLength !== undefined)\n\t\t\t\targs.length = fixedArgsLength;\n\t\t\tlet thisArgs = [this];\n\t\t\tif (getAdditionalArgs)\n\t\t\t\tthisArgs = thisArgs.concat(getAdditionalArgs.call(this), args);\n\t\t\telse\n\t\t\t\tthisArgs = thisArgs.concat(args);\n\t\t\tlet result = cache.get(thisArgs);\n\t\t\tif (result === undefined && !cache.has(thisArgs))\n\t\t\t{\n\t\t\t\tcache.set(thisArgs, UNDEFINED);\n\t\t\t\tresult = func.apply(this, args);\n\t\t\t\tif (result !== undefined)\n\t\t\t\t\tcache.set(thisArgs, result);\n\t\t\t}\n\t\t\treturn result === UNDEFINED ? undefined : result;\n\t\t} as Func;\n\t}\n\n\tget:Func;\n}\n\nexport type MemoizeParams<F extends AnyFunction> = {\n\tfunction: F,\n\tgetAdditionalArgs?: ()=>any[],\n\tfixedArgsLength?: number,\n};\n\n/**\n * Creates a memoized version of a function.\n */\nexport default function memoize<F extends AnyFunction>(params:MemoizeParams<F>):F;\n\n/**\n * A method decorator that creates a memoized version of a method.\n */\nexport default function memoize<T extends AnyFunction>(target: object, propertyKey: string | symbol, descriptor: TypedPropertyDescriptor<T>):TypedPropertyDescriptor<T> | void;\n\nexport default function memoize<T extends AnyFunction>():TypedPropertyDescriptor<T> | void\n{\n\t// called as decorator, target is prototype; return modified descriptor\n\tif (arguments.length == 3)\n\t{\n\t\tlet target = arguments[0] as object;\n\t\tlet propertyKey = arguments[1] as string|symbol;\n\t\tlet descriptor = arguments[2] as TypedPropertyDescriptor<T>;\n\t\treturn decorate(descriptor);\n\t}\n\n\t// called as function\n\tlet params = arguments[0] as MemoizeParams<T>;\n\tif (typeof params === 'function')\n\t\tparams = {function: params};\n\tif (arguments.length == 1 && params && typeof params.function === 'function')\n\t{\n\t\treturn new Memoizer(params.function, params.getAdditionalArgs, params.fixedArgsLength).get;\n\t}\n\telse\n\t{\n\t\tthrow new Error(\"Usage: memoize(params:{ function:Function, getAdditionalArgs?:()=>any[], fixedArgsLength?:number })\");\n\t}\n}\n\ntype DecorateMemoizeParams<T extends AnyFunction> = Partial<Pick<MemoizeParams<T>, 'getAdditionalArgs' | 'fixedArgsLength'>>;\n\nfunction decorate<T extends AnyFunction>(descriptor:TypedPropertyDescriptor<T>, params?:DecorateMemoizeParams<T>)\n{\n\tif (descriptor && typeof descriptor.value === 'function')\n\t\tdescriptor.value = new Memoizer(descriptor.value, params && params.getAdditionalArgs, params && params.fixedArgsLength).get;\n\telse if (descriptor && (descriptor.set || descriptor.get))\n\t\tthrow new Error('memoize cannot be used as a decorator for a setter or getter');\n\treturn descriptor;\n}\n\n// /**\n//  * Generates a method decorator that creates a memoized version of a function with additional args to control memoization\n//  * @param getAdditionalMemoizeArgs A function that returns additional arguments for controlling memoization.\n//  *                                 If this is an inline function, it must be defined like\n//  *                                     <code>function() { return [this.a, this.b]; }</code>\n//  *                                 rather than\n//  *                                     <code>() => [this.a, this.b]</code>\n//  *                                 because when decorators are evaluated the 'this' context is undefined.\n//  */\n// export function memoizeWith<T, TARGET>(getAdditionalMemoizeArgs:(this:TARGET, self:TARGET)=>any[])\n// \t:<T>(\n// \t\ttarget: TARGET,\n// \t\tpropertyKey: string | symbol,\n// \t\tdescriptor: TypedPropertyDescriptor<T>\n// \t) => TypedPropertyDescriptor<T> | void\n// {\n// \treturn (target: Object, propertyKey: string | symbol, descriptor: TypedPropertyDescriptor<T>):TypedPropertyDescriptor<T> => {\n// \t\treturn decorate(descriptor, getAdditionalMemoizeArgs);\n// \t};\n// }\n\n/**\n * Generates a method decorator that creates a memoized version of a function with additional args to control memoization\n * @param getMemoizeParams_propName The name of another class method that returns additional arguments for controlling memoization.\n */\nexport function memoizeWith<T extends AnyFunction, P extends string, TARGET extends {[X in P]: (this:TARGET)=>any[]}>(getMemoizeParams_propName:P):<T>(\n\t\ttarget: TARGET,\n\t\tpropertyKey: string | symbol,\n\t\tdescriptor: TypedPropertyDescriptor<T>\n\t) => TypedPropertyDescriptor<T> | void\n{\n\treturn (target: TARGET, propertyKey: string | symbol, descriptor: TypedPropertyDescriptor<T>):TypedPropertyDescriptor<T> => {\n\t\treturn decorate(\n\t\t\tdescriptor,\n\t\t\t{\n\t\t\t\tgetAdditionalArgs: function getAdditionalArgs(this:TARGET) {\n\t\t\t\t\tlet fn:()=>any[] = this[getMemoizeParams_propName] as any;\n\t\t\t\t\treturn fn.call(this);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t};\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/memoize.ts"],"sourceRoot":""}